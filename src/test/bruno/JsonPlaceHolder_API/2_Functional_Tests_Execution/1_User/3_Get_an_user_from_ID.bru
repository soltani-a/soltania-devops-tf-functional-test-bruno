meta {
  name: 3_Get_an_user_from_ID
  type: http
  seq: 3
}

get {
  url: {{url}}/{{user_path_root}}/{{userId}}
  body: none
  auth: inherit
}

script:pre-request {
  // --- Showcase Strategy: Handling Mock API Limitations ---
  
  // NOTE: JSONPlaceholder ne persiste pas les cr√©ations. 
  // L'ID 101 (cr√©√© √† l'√©tape pr√©c√©dente) retournerait une 404 ici.
  // Pour garantir un test vert (200 OK), on utilise l'ID r√©cup√©r√© √† l'√©tape 1 
  // (un utilisateur r√©el entre 1 et 10).
  
  let targetId = bru.getVar("existingUserId");

  // --- Self-Healing (Auto-r√©paration) ---
  // Si l'√©tape 1 n'a pas tourn√©, on force un ID par d√©faut pour √©viter le crash.
  if (!targetId) {
    targetId = 1; 
    console.log("[Showcase Info] No existingUserId found. Defaulting to ID 1.");
  } else {
    console.log(`[Showcase Info] Fetching real user with ID: ${targetId}`);
  }

  // On d√©finit la variable {{userId}} utilis√©e dans l'URL
  bru.setVar("userId", targetId);
}

tests {
  // 1. Validation de la requ√™te
  test("Status code is 200 OK", function() {
    expect(res.getStatus()).to.equal(200);
  });

  // 2. Validation de la coh√©rence des donn√©es
  test("Returned ID matches requested ID", function() {
    // On s'assure que l'API nous renvoie bien l'user qu'on a demand√©
    // (et pas une redirection ou un cache bizarre)
    const requestedId = parseInt(bru.getVar("userId"));
    expect(res.getBody().id).to.equal(requestedId);
  });

  // 3. Validation de structure (Deep Check)
  test("User has critical fields (email, address)", function() {
    const user = res.getBody();
    expect(user).to.have.property('username').that.is.a('string');
    expect(user).to.have.property('email').that.include('@'); // V√©rif basique format email
    expect(user.address).to.have.property('city');
  });
  
  // 4. Performance
  test("Response time < 500ms", function() {
    expect(res.getResponseTime()).to.be.below(500);
  });
}

docs {
  # üß™ Scenario: User Retrieval & Mock Handling
  
  This request demonstrates how to handle **Mock API Limitations** in an automated pipeline while ensuring test stability.
  
  ## üß† The "Mock Paradox" Strategy
  In a production environment, this test would fetch the User ID created in the previous `POST` request. 
  However, **JsonPlaceholder** is a non-persistent mock API: resources created via POST are faked and do not actually exist on the server.
  
  * **Naive Approach**: Fetching the ID from Step 2 -> Returns `404 Not Found` (Pipeline Fails ‚ùå).
  * **Showcase Approach**: The pre-request script intelligently swaps the target to `existingUserId` (a real user captured in Step 1) -> Returns `200 OK` (Pipeline Passes ‚úÖ).
  
  ## üõ°Ô∏è Self-Healing Logic
  To ensures the test suite is robust:
  * The script checks if `existingUserId` is available.
  * If missing (e.g., test run in isolation), it defaults to `ID: 1`.
  * This guarantees the test **never crashes** due to missing context.
  
  ## ‚úÖ Quality Gates
  * **Data Consistency**: Verifies that the API returns the exact ID requested (`requested_id == returned_id`).
  * **Deep Schema**: Validates nested objects (address.city) and basic email formatting.
}