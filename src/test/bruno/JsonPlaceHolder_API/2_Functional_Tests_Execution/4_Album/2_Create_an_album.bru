meta {
  name: 2_Create_an_album
  type: http
  seq: 2
}

post {
  url: {{url}}/{{albums_path_root}}
  body: json
  auth: inherit
}

headers {
  Content-type: application/json; charset=UTF-8
}

body:json {
  {
    "userId": {{userId}},
    "title": "{{albumTitle}}"
  }
}

script:pre-request {
  // --- Showcase Strategy: Contextual Data Generation ---
  
  // 1. Self-Healing (Robustesse)
  // On s'assure d'avoir un UserID valide pour attacher l'album.
  if (!bru.getVar("userId")) {
    bru.setVar("userId", 1);
    console.log("[Showcase Info] Defaulting to User ID 1 for album creation.");
  }

  // 2. GÃ©nÃ©ration de contenu "Documentation Technique"
  // On simule des albums de screenshots ou de diagrammes d'infra.
  const topics = [
    "AWS Network Topology", 
    "Kubernetes Pod Logs", 
    "CI/CD Pipeline Screenshots", 
    "Database Schema Versions"
  ];
  
  const randomTopic = topics[Math.floor(Math.random() * topics.length)];
  const year = new Date().getFullYear();
  
  // Ex: "CI/CD Pipeline Screenshots - 2024 Archive"
  const title = `${randomTopic} - ${year} Archive (Soltani-A)`;

  bru.setVar("albumTitle", title);
}

script:post-response {
  // --- Showcase Best Practice: Runtime Scope ---
  
  // Correction : On utilise setVar (Session) et PAS setEnvVar (Fichier).
  // Cela garde le fichier .bru propre et Ã©vite les conflits git.
  
  const newId = res.body.id;
  
  if(newId) {
    bru.setVar("newAlbumId", newId);
    console.log(`[Showcase Info] Created Album ID: ${newId} "${bru.getVar("albumTitle")}"`);
  }
}

tests {
  // 1. Validation de crÃ©ation
  test("Status code is 201 Created", function() {
    expect(res.getStatus()).to.equal(201);
  });

  // 2. Validation de contenu
  test("Album title matches generated data", function() {
    const sentTitle = bru.getVar("albumTitle");
    expect(res.getBody().title).to.equal(sentTitle);
  });

  // 3. Validation Relationnelle
  test("Album is linked to correct User", function() {
    const expectedUserId = parseInt(bru.getVar("userId"));
    expect(res.getBody().userId).to.equal(expectedUserId);
  });
}

docs {
  # ðŸ“‚ Scenario: Digital Asset Management (Dynamic Creation)

  This request simulates the creation of a new **Documentation Album** within the system. It demonstrates how to generate semantically relevant data for specific business domains (DevOps/Infrastructure).

  ## âœ¨ Technical Highlights

  ### 1. Semantic Data Generation
  The `pre-request` script moves away from generic strings to generate **Domain-Specific Content**:
  * **Topics**: Randomly selects infrastructure themes (AWS Topology, K8s Logs, CI/CD Pipelines).
  * **Versioning**: Appends the current year and corporate branding (`Soltani-A`) to the title.

  ### 2. State Hygiene (Runtime Variables)
  * **Best Practice**: The script captures the returned `id` into `newAlbumId` using `bru.setVar` (session memory).
  * **Anti-Pattern Avoidance**: It explicitly avoids modifying the persistent environment file (`setEnvVar`), ensuring the repository remains stateless and clean during CI runs.

  ### 3. Robustness
  * **Self-Healing**: Checks for a valid parent `userId`. If missing, it defaults to a safe fallback (ID: 1) to prevent the test from crashing in isolation.

  ## âœ… Quality Gates
  * **Status**: 201 Created.
  * **Echo Verification**: Validates that the title persisted by the API matches the dynamically generated string.
  * **Relational Integrity**: Confirms the album is successfully linked to the correct User entity.
}